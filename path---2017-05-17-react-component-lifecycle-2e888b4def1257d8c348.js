webpackJsonp([0x9379216e8d0b],{607:function(n,t){n.exports={data:{markdownRemark:{tableOfContents:'<ul>\n<li><a href="#%E7%B5%84%E4%BB%B6">組件</a></li>\n<li>\n<p><a href="#%E7%B5%84%E4%BB%B6%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F">組件生命週期</a></p>\n<ul>\n<li><a href="#%E5%8A%A0%E8%BC%89-mounting">加載 (Mounting)</a></li>\n<li><a href="#%E6%9B%B4%E6%96%B0-updating">更新 (Updating)</a></li>\n<li><a href="#%E6%96%B7%E9%96%8B%E9%80%A3%E6%8E%A5-unmounting">斷開連接 (Unmounting)</a></li>\n<li>\n<p><a href="#%E5%85%B6%E4%BB%96%E5%85%A7%E7%BD%AE%E6%96%B9%E6%B3%95">其他內置方法</a></p>\n<ul>\n<li>\n<p><a href="#constructor">constructor()</a></p>\n<ul>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85">注意事項</a></li>\n</ul>\n</li>\n<li><a href="#componentwillmount">componentWillMount()</a></li>\n<li>\n<p><a href="#render">render()</a></p>\n<ul>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-1">注意事項</a></li>\n</ul>\n</li>\n<li><a href="#componentdidmount">componentDidMount()</a></li>\n<li><a href="#%E6%B8%AC%E8%A9%A6%E4%BB%A3%E7%A2%BC">測試代碼</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',internal:{content:'---\ntitle: React 組件生命週期 - 加載組件\n# headerImage: "LEYYumy.jpg"\ntags:\n  - React\n  - Web\ndate: 2017-05-16 22:40:00\n---\n\n## 組件\n`React`提供`React.Component`，我們可以透過使用組件，拆分UI為可以重複使用的獨立部分。`React.Component`是一個抽象的base class。我們甚少直接運用`React.Component`，通常是透過創建一個子類，並使用`render()`方法。\n\n例子：\n```JavaScript\nclass Greeting extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n如果你不選擇使用ES6，你可以使用模組`create-react-class`。你可以參考[React Without ES6](https://facebook.github.io/react/docs/react-without-es6.html)。\n下面這一段和ES6的寫法效果一樣：\n```JavaScript\nvar createReactClass = require(\'create-react-class\');\nvar Greeting = createReactClass({\n  render: function() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n});\n```\n\n## 組件生命週期\n\n每一個組件都會有幾個生命週期的方法，你可以在程序運行的指定時間，透過覆蓋他們來運行特定代碼。對於這些方法，我們會用`will-`來表示它會在某些事情發生之前的一刻被調用，而`did-`則是表示它會在某些事情發生之後的一刻被調用。本文會細說加載組件中發生了什麼事情。\n\n### 加載 (Mounting)\n1. `constructor()`\n1. `componentWillMount()`\n1. `render()`\n1. `componentDidMount()`\n\n### 更新 (Updating)\n當 props 或者 state 更新的時候，下面這些方法會被調用：\n\n1. componentWillReceiveProps()\n1. shouldComponentUpdate()\n1. componentWillUpdate()\n1. render()\n1. componentDidUpdate()\n\n### 斷開連接 (Unmounting)\n當組件脫離DOM的時候，下面這個方法回被調用：\n\n1. componentWillUnmount()\n\n### 其他內置方法\n1. setState()\n1. forceUpdate()\n\n我們會在下文討論一下React是如何加載組件。\n\n{% img /img/react-mount.svg 300 auto React LifeCycle Mount %}\n\n#### constructor()\n```JavaScript\nconstructor(props)\n```\n\n在React加載組件之前，它會調用`constructor`。你可以在`constructor`中去賦予組件的初始`state`。如果你使用`props`創造初始`state`的話，這也是可以接受的。這會很有效地`fork`組件的`props`，然後賦予初始`state`的值。\n\n有效的`constructor`例子：\n```JavaScript\nconstructor(props) {\n  super(props);\n  this.state = {\n    color: props.initialColor\n  };\n}\n```\n\n##### 注意事項\n1. 如果你不需要賦予初始`state`，你不需要在 React 的組件中植入`constructor`。\n1. 當你使用在`React.Component`的子類中加載`constructor()`方法時，你應該第一時間調用`super(props)`，而不是在任何statement之後。不然，我們獲取`this.props`值的時候，它會是`undefined`。\n1. 在一些類似上面的例子，`state`未必會及時與任何的`props`更新。如果你需要同步`state`的話，你其實是想要[lift the state up](https://facebook.github.io/react/docs/lifting-state-up.html)。\n\n#### componentWillMount()\n```JavaScript\ncomponentWillMount()\n```\n\n它會在組件`render()`之前執行一次，然後不能再執行。如果在這裡定義了`setState`方法，頁面只會在加載之前更新一次，不會重複渲染。React 官方推薦使用`constructor()`代替這個方法。\n\n#### render()\n`React.Component`必須有這個方法，即使你返回`null`，或者`false`。當你返回`null`，或者`false`的時候，`ReactDOM.findDOMNode(this)` 會返回`null`。\n\n當它被調用的時候，它會檢查`this.props`和`this.state`，然後返回一個單獨的 React 元素。這個元素會是一個純正的`DOM`組件，例如<div />，或者自定義的 composite 組件。\n\n##### 注意事項\n1. `render()`方法應該是`pure`：它不會改寫任何組件的`state`。每一次調用它都會返回同樣的結果。它不會直接接觸到瀏覽器層面。\n1. 如果你需要接觸到瀏覽器層面，你應該在`componentDidMount()`或者其他生命週期方法中接觸瀏覽器。\n1. 保持`render()`方法 pure 來讓組件更加容易被人理解。\n\n#### componentDidMount()\n```JavaScript\ncomponentDidMount()\n```\n\n它會在組件加載之後執行一次。如果你的初始程序需要DOM nodes，你應該在這裡寫。如果你需要從其他地方加載資料，這裡也是一個不錯的地方去執行網絡請求。如果在這裡定義了`setState`方法，會觸發重複渲染。\n\n#### 測試代碼\n```JavaScript\nclass Greeting extends React.Component {\n  _log(method, args) {\n    console.log(method, args);\n  }\n\n  constructor(props) {\n    super(props);\n    console.log(\'constructor\', props);\n  }\n\n  render() {\n    this._log(\'render\', this.props.name);\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n\n  componentWillMount() {\n    this._log(\'componentWillMount\');\n  }\n\n  componentDidMount() {\n    this._log(\'componentDidMount\');\n  }\n}\n\nReactDOM.render(\n  <Greeting name="Calpa" />,\n  document.getElementById(\'app\')\n);\n```\n\nConsole Output:\n```\n"constructor" Object {\n  name: "Calpa"\n}\n"componentWillMount" undefined\n"render" "Calpa"\n"componentDidMount" undefined\n```\n\n你可以在[CodePen](https://codepen.io/calpa/full/xdJrQm/)中獲取，並測試這段代碼。\n\n不知道拿哪一張當封面好。。。\n'},frontmatter:{title:"React 組件生命週期 - 加載組件"}}},pathContext:{slug:"/react-component-lifecycle/"}}}});
//# sourceMappingURL=path---2017-05-17-react-component-lifecycle-2e888b4def1257d8c348.js.map