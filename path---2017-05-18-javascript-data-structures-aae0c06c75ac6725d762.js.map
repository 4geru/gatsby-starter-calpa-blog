{"version":3,"sources":["webpack:///path---2017-05-18-javascript-data-structures-aae0c06c75ac6725d762.js","webpack:///./.cache/json/2017-05-18-javascript-data-structures.json"],"names":["webpackJsonp","398","module","exports","data","markdownRemark","tableOfContents","internal","content","frontmatter","title","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,gBAAA,mWAAAC,UAA2YC,QAAA,+tIAA8zIC,aAAgBC,MAAA,8BAAqCC,aAAgBC,KAAA","file":"path---2017-05-18-javascript-data-structures-aae0c06c75ac6725d762.js","sourcesContent":["webpackJsonp([274735409455307],{\n\n/***/ 398:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"tableOfContents\":\"<ul>\\n<li><a href=\\\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\\\">数据类型</a></li>\\n<li>\\n<p><a href=\\\"#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95\\\">判断方法</a></p>\\n<ul>\\n<li><a href=\\\"#typeof\\\">typeof</a></li>\\n<li><a href=\\\"#objectprototypetostring\\\">Object.prototype.toString()</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\\\">参考资料</a></li>\\n</ul>\",\"internal\":{\"content\":\"---\\ntitle: 利用 ECMAScript 学习如何判断数据类型\\nheaderImage: KMksHxZ.png\\ndate: 2017-05-18 14:00\\ntags:\\n  - JavaScript\\n  - ECMAScript\\n---\\n\\n每一种编程语言都有数据结构，但他们各有不同之处。JavaScript 是一种动态语言，变量的类型不用提前声明，你可以使用同一个变量来保存不同的数据类型。\\n```JavaScript\\nvar a = 'apple'; // String type\\nvar a = 42; // Number type\\nvar a = true; // Boolean type\\n```\\n\\n这就和Python的写法差不多:\\n```python\\na = 'apple' // String type\\na = 42 // Number type\\na = True // Boolean type\\n```\\n## 数据类型\\n[ECMAScript 标準](https://tc39.github.io/ecma262/#sec-ecmascript-overview)明确定义了7种数据类型：6种原始类型 (Primitive value) 和Object。\\n\\n{% img /img/javascript-data-structures.svg 300 auto JavaScript Data Structure %}\\n\\n原始数据类型：\\n1. Undefined\\n1. Null\\n1. Boolean\\n1. Number\\n1. String\\n1. Symbol (ECMAScript 2015)\\n\\n## 判断方法\\n\\n我们可以透过使用`typeof`和`Object.prototype.toString()`来判断数据类型。\\n\\n### typeof\\n\\n在一开始设计 JavaScript 时，数值是由一个标签以及实际数据值表示的。对于基本类型，标签是1；而对于对象类型，标签是0。由于null代表的是空指针(里面都是0)，null的类型标签会是0。因此`typeof null`就会返回\\\"object\\\";\\n\\n```JavaScript\\ntypeof undefined; // \\\"undefined\\\"\\ntypeof Boolean;   // \\\"function\\\"\\ntypeof true;      // \\\"boolean\\\"\\ntypeof 42;        // \\\"number\\\"\\ntypeof \\\"42\\\";      // \\\"string\\\"\\ntypeof Symbol();  // \\\"symbol\\\"\\n```\\n\\n我们可以看一下ECMAScript是怎样定义typeof的：\\n\\n1. Let val be the result of evaluating UnaryExpression.\\n1. If Type(val) is Reference, then\\n  a. If IsUnresolvableReference(val) is true, return \\\"undefined\\\".\\n1. Set val to ? GetValue(val).\\n1. Return a String according to Table 35.\\n\\nTable 35: typeof Operator Results\\n\\n| Typeof val | 结果     |\\n| :------------- | :------------- |\\n| Item One       | Item Two       |\\n|Type of val\\t|Result|\\n|Undefined\\t|\\\"undefined\\\"|\\n|Null|\\t\\\"object\\\"|\\n|Boolean\\t|\\\"boolean\\\"|\\n|Number|\\t\\\"number\\\"|\\n|String\\t|\\\"string\\\"|\\n|Symbol|\\t\\\"symbol\\\"|\\n|Object (ordinary and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (standard exotic and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (implements [[Call]])\\t|\\\"function\\\"|\\n|Object (non-standard exotic and does not implement [[Call]])\\t|Implementation-defined. Must not be \\\"undefined\\\", \\\"boolean\\\",  \\\"function\\\", \\\"number\\\", \\\"symbol\\\", or \\\"string\\\".|\\n\\n另外，如果直接用`typeof`来判断 NaN 的话，它会返回`\\\"number\\\"`，对于 NaN 我们可以用`isNaN`方法来判断是否一个数字。\\n```JavaScript\\ntypeof NaN; // \\\"number\\\"\\nisNaN(NaN); // true\\n```\\n### Object.prototype.toString()\\n\\n我们可以利用`Object.prototype.toString.call()`或者`Object.prototype.toString.apply()`这两个方法判断 Object 的类型，以及 null：\\n```JavaScript\\nObject.prototype.toString.call(undefined);   // \\\"[object Undefined]\\\"\\nObject.prototype.toString.call(new Date);    // \\\"[object Date]\\\"\\nObject.prototype.toString.call(new String);  // \\\"[object String]\\\"\\nObject.prototype.toString.call(Math);        // \\\"[object Math]\\\"\\nObject.prototype.toString.call(null);        // \\\"[object Null]\\\"\\n```\\n\\nECMAScript 19.1.3.6 明确定义 Object.prototype.toString()：\\n\\n1.  If the `this` value is `undefined`, return `\\\"[object Undefined]\\\"`.\\n2.  If the `this` value is `null`, return `\\\"[object Null]\\\"`.\\n3.  Let `O` be ! [ToObject](https://tc39.github.io/ecma262/#sec-toobject)(`this` value).\\n4.  Let `isArray` be ? [IsArray](https://tc39.github.io/ecma262/#sec-isarray)(`O`).\\n5.  If `isArray` is `true`, let `builtinTag` be `\\\"Array\\\"`.\\n6.  Else if `O` is a String exotic object, let `builtinTag` be `\\\"String\\\"`.\\n7.  Else if `O` has a [[ParameterMap]] internal slot, let `builtinTag` be `\\\"Arguments\\\"`.\\n8.  Else if `O` has a [[Call]] internal method, let `builtinTag` be `\\\"Function\\\"`.\\n9.  Else if `O` has an [[ErrorData]] internal slot, let `builtinTag` be `\\\"Error\\\"`.\\n10.  Else if `O` has a [[BooleanData]] internal slot, let `builtinTag` be `\\\"Boolean\\\"`.\\n11.  Else if `O` has a [[NumberData]] internal slot, let `builtinTag` be `\\\"Number\\\"`.\\n12.  Else if `O` has a [[DateValue]] internal slot, let `builtinTag` be `\\\"Date\\\"`.\\n13.  Else if `O` has a [[RegExpMatcher]] internal slot, let `builtinTag` be `\\\"RegExp\\\"`.\\n14.  Else, let `builtinTag` be `\\\"Object\\\"`.\\n15.  Let `tag` be ? [Get](https://tc39.github.io/ecma262/#sec-get-o-p)(`O`, @@toStringTag).\\n16.  If [Type](https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values)(`tag`) is not String, let `tag` be `builtinTag`.\\n17.  Return the String that is the result of concatenating `\\\"[object \\\"`, `tag`, and `\\\"]\\\"`.\\n\\n## 参考资料\\n1. [ECMAScript® 2018 Language Specification](https://tc39.github.io/ecma262/#sec-ecmascript-overview)\\n\"},\"frontmatter\":{\"title\":\"利用 ECMAScript 学习如何判断数据类型\"}}},\"pathContext\":{\"slug\":\"/javascript-data-structures/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2017-05-18-javascript-data-structures-aae0c06c75ac6725d762.js","module.exports = {\"data\":{\"markdownRemark\":{\"tableOfContents\":\"<ul>\\n<li><a href=\\\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\\\">数据类型</a></li>\\n<li>\\n<p><a href=\\\"#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95\\\">判断方法</a></p>\\n<ul>\\n<li><a href=\\\"#typeof\\\">typeof</a></li>\\n<li><a href=\\\"#objectprototypetostring\\\">Object.prototype.toString()</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\\\">参考资料</a></li>\\n</ul>\",\"internal\":{\"content\":\"---\\ntitle: 利用 ECMAScript 学习如何判断数据类型\\nheaderImage: KMksHxZ.png\\ndate: 2017-05-18 14:00\\ntags:\\n  - JavaScript\\n  - ECMAScript\\n---\\n\\n每一种编程语言都有数据结构，但他们各有不同之处。JavaScript 是一种动态语言，变量的类型不用提前声明，你可以使用同一个变量来保存不同的数据类型。\\n```JavaScript\\nvar a = 'apple'; // String type\\nvar a = 42; // Number type\\nvar a = true; // Boolean type\\n```\\n\\n这就和Python的写法差不多:\\n```python\\na = 'apple' // String type\\na = 42 // Number type\\na = True // Boolean type\\n```\\n## 数据类型\\n[ECMAScript 标準](https://tc39.github.io/ecma262/#sec-ecmascript-overview)明确定义了7种数据类型：6种原始类型 (Primitive value) 和Object。\\n\\n{% img /img/javascript-data-structures.svg 300 auto JavaScript Data Structure %}\\n\\n原始数据类型：\\n1. Undefined\\n1. Null\\n1. Boolean\\n1. Number\\n1. String\\n1. Symbol (ECMAScript 2015)\\n\\n## 判断方法\\n\\n我们可以透过使用`typeof`和`Object.prototype.toString()`来判断数据类型。\\n\\n### typeof\\n\\n在一开始设计 JavaScript 时，数值是由一个标签以及实际数据值表示的。对于基本类型，标签是1；而对于对象类型，标签是0。由于null代表的是空指针(里面都是0)，null的类型标签会是0。因此`typeof null`就会返回\\\"object\\\";\\n\\n```JavaScript\\ntypeof undefined; // \\\"undefined\\\"\\ntypeof Boolean;   // \\\"function\\\"\\ntypeof true;      // \\\"boolean\\\"\\ntypeof 42;        // \\\"number\\\"\\ntypeof \\\"42\\\";      // \\\"string\\\"\\ntypeof Symbol();  // \\\"symbol\\\"\\n```\\n\\n我们可以看一下ECMAScript是怎样定义typeof的：\\n\\n1. Let val be the result of evaluating UnaryExpression.\\n1. If Type(val) is Reference, then\\n  a. If IsUnresolvableReference(val) is true, return \\\"undefined\\\".\\n1. Set val to ? GetValue(val).\\n1. Return a String according to Table 35.\\n\\nTable 35: typeof Operator Results\\n\\n| Typeof val | 结果     |\\n| :------------- | :------------- |\\n| Item One       | Item Two       |\\n|Type of val\\t|Result|\\n|Undefined\\t|\\\"undefined\\\"|\\n|Null|\\t\\\"object\\\"|\\n|Boolean\\t|\\\"boolean\\\"|\\n|Number|\\t\\\"number\\\"|\\n|String\\t|\\\"string\\\"|\\n|Symbol|\\t\\\"symbol\\\"|\\n|Object (ordinary and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (standard exotic and does not implement [[Call]])\\t|\\\"object\\\"|\\n|Object (implements [[Call]])\\t|\\\"function\\\"|\\n|Object (non-standard exotic and does not implement [[Call]])\\t|Implementation-defined. Must not be \\\"undefined\\\", \\\"boolean\\\",  \\\"function\\\", \\\"number\\\", \\\"symbol\\\", or \\\"string\\\".|\\n\\n另外，如果直接用`typeof`来判断 NaN 的话，它会返回`\\\"number\\\"`，对于 NaN 我们可以用`isNaN`方法来判断是否一个数字。\\n```JavaScript\\ntypeof NaN; // \\\"number\\\"\\nisNaN(NaN); // true\\n```\\n### Object.prototype.toString()\\n\\n我们可以利用`Object.prototype.toString.call()`或者`Object.prototype.toString.apply()`这两个方法判断 Object 的类型，以及 null：\\n```JavaScript\\nObject.prototype.toString.call(undefined);   // \\\"[object Undefined]\\\"\\nObject.prototype.toString.call(new Date);    // \\\"[object Date]\\\"\\nObject.prototype.toString.call(new String);  // \\\"[object String]\\\"\\nObject.prototype.toString.call(Math);        // \\\"[object Math]\\\"\\nObject.prototype.toString.call(null);        // \\\"[object Null]\\\"\\n```\\n\\nECMAScript 19.1.3.6 明确定义 Object.prototype.toString()：\\n\\n1.  If the `this` value is `undefined`, return `\\\"[object Undefined]\\\"`.\\n2.  If the `this` value is `null`, return `\\\"[object Null]\\\"`.\\n3.  Let `O` be ! [ToObject](https://tc39.github.io/ecma262/#sec-toobject)(`this` value).\\n4.  Let `isArray` be ? [IsArray](https://tc39.github.io/ecma262/#sec-isarray)(`O`).\\n5.  If `isArray` is `true`, let `builtinTag` be `\\\"Array\\\"`.\\n6.  Else if `O` is a String exotic object, let `builtinTag` be `\\\"String\\\"`.\\n7.  Else if `O` has a [[ParameterMap]] internal slot, let `builtinTag` be `\\\"Arguments\\\"`.\\n8.  Else if `O` has a [[Call]] internal method, let `builtinTag` be `\\\"Function\\\"`.\\n9.  Else if `O` has an [[ErrorData]] internal slot, let `builtinTag` be `\\\"Error\\\"`.\\n10.  Else if `O` has a [[BooleanData]] internal slot, let `builtinTag` be `\\\"Boolean\\\"`.\\n11.  Else if `O` has a [[NumberData]] internal slot, let `builtinTag` be `\\\"Number\\\"`.\\n12.  Else if `O` has a [[DateValue]] internal slot, let `builtinTag` be `\\\"Date\\\"`.\\n13.  Else if `O` has a [[RegExpMatcher]] internal slot, let `builtinTag` be `\\\"RegExp\\\"`.\\n14.  Else, let `builtinTag` be `\\\"Object\\\"`.\\n15.  Let `tag` be ? [Get](https://tc39.github.io/ecma262/#sec-get-o-p)(`O`, @@toStringTag).\\n16.  If [Type](https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values)(`tag`) is not String, let `tag` be `builtinTag`.\\n17.  Return the String that is the result of concatenating `\\\"[object \\\"`, `tag`, and `\\\"]\\\"`.\\n\\n## 参考资料\\n1. [ECMAScript® 2018 Language Specification](https://tc39.github.io/ecma262/#sec-ecmascript-overview)\\n\"},\"frontmatter\":{\"title\":\"利用 ECMAScript 学习如何判断数据类型\"}}},\"pathContext\":{\"slug\":\"/javascript-data-structures/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2017-05-18-javascript-data-structures.json\n// module id = 398\n// module chunks = 274735409455307"],"sourceRoot":""}